sprint-4: execution de la méthode de l'url
    -si valeur de retour -> string
        on affiche
sprint4-4-bis:
    -créer classe ModelView
        -attributs:
            -view (chaine de caractères)
    -dans une méthode du controller, on peut créer un ModelView
        -on set l'attribut view au nom de la page
        -on fait en sorte d'afficher le contenu de cette page avec Dispatcher.
sprint-5:
	-mandefa donnée any am view
	-anaty ModelView
		-misy url
		-misy Map<String, Object> data

sprint 6:
	-mandefa donnée any am controller
		sprint-3-ter: -(gestion mapping url avec accolade) permettre ce genre d'url : /etudiants/{id} correspondant à /etudiants/25 par exemple!
		
		tsotra: -(matching nom anaty accolage sy nom argument) pour le cas avec l'accolade raha mitovy ny argument anle controller sy le anaty {} de alefa le methode
		
		bis: -(misy annotation @RequestParam(String arg)) sinon raha misy tsisy de jerena hoe misy requestparam mitovy aminy ve, de raha mitovy de alefa.
		
		ter: pour le cas où misy request.getParam mitovy anarana anle argument anle controller de alefa any,

sprint 7:
    -asiana GET sy POST
    -comment?:
        -ovaina le map<URL, ClassMethod> lasa map<URL, List<ClassMethod>>
            -ClassMethod lasa:
                Class class;
                Method method;
                String httpMethod; // POST OU GET

sprint 8 :
    -Pour les méthodes post qui recoivent des objets en arguments
    -depuis le formulaire on envoie des inputs, on transforme ça en linkedhashmap dans le FrontServlet  puis on crée l'instance de l'objet avec les valeurs envoyées depuis le front et on execute la fonction 

    -test: créer une page html dans le projet de test (test_project_new) avec un formulaire d'insertion d'une classe Paiement par exemple, 
        -créer la classe Paiement et une autre classe Utilisateur
            -dans Paiement on aura Utilisateur 
        -dans ce test on créera les données en dur, pas de persistence
        -créer un controller pour renvoyer une liste des utilisateurs dont les données seront crées à la volée dans le controller lui même pour le test
        -créer un controller dans le projet de test pour insertion de paiement 
        -dans la page html -> liste déroulante de utilisateur dans le champ utilisateur du formulaire 
        -le formulaire renverra vers l'endpoint du controller d'insertion de paiement et dans la méthode d'insertion de paiement on retournera un ModelView avec le paiement nouvellement crée redirigeant vers une page paiement-details.html et on affiche le paiement crée.

sprint 9:
    -JSON

sprint 10:
    - upload de fichier
        - on crée un formulaire avec enctype="multipart/form-data"
        - on construit un map dans FrontServlet
            - on récupère les parties du fichier avec request.getParts()
            - on crée un tableau de bytes pour chaque partie
            - on crée une Map<String, Byte[]> avec le nom du fichier et le tableau de bytes
        - on crée un controller qui reçoit le fichier en argument

sprint 11:
    - Session:
        -on peut annoter un argument de fonction depuis une méthode d'une classe Controller avec l'annotation @Session, l'argument doit impérativement
        être de type Map<String, Object>, on peut accéder aux variables de HttpSession depuis ce Map
        -dans FrontServlet lors de l'appel de la fonction (via reflect) si on a une variable de session, on copie HttpSession dans un Map puis on donne ça en argument
        a la méthode, puis après avoir executé la méthode on passe le contenu de la Map qu'on a copié ensuite à HttpSession pour persister le changement

        Schema:
            -coté développeur
                @Controller
                public class TestController {

                    // service simulé copiant Spring Boot mais on a pas besoin de ça, c'est juste un exemple
                    StudentService studentService;

                    @GET
                    @UrlMapping("/test")
                    public void testMethod(@Session Map<String, Object> session, Integer id) {
                        // simuler une méthode pour trouver un objet via son id
                        Student st = studentService.findById(id);
                        if(st != null) {
                            // persistence dans session
                            session.put("studen", st);
                        }
                    }
                }

sprint 11-bis:
    -annoter les methodes d'actions des controlleurs avec des annotations de role:
        -@Role(String... role) : seul les utilisateurs au role spécifié peuvent appeler la méthode
        -@Authorized : l'utilisateur doit être connecté
        -@Anonym : n'importe qui peut appeler la méthode
